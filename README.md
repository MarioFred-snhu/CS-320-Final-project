# CS-320-Final-project
Software testing and automation 

How can I ensure that my code, program, or software is functional and secure?

To ensure functionality, I follow a test-driven development (TDD) approach by writing comprehensive JUnit tests that address both expected behaviors and edge cases. This method verifies that the application logic operates correctly and consistently. Additionally, I implement strict input validation to prevent malformed or invalid data from entering the system, which helps maintain the program’s integrity.

Security begins with a clean design. I use encapsulation to limit access to sensitive fields, enforce unique identifiers to prevent duplication, and adopt a defensive coding style to minimize vulnerabilities. Although this project mainly utilizes in-memory storage, I have structured it to allow for future enhancements, such as authentication, encryption, or secure database integration. Validating and sanitizing user input is a crucial aspect of maintaining software security.

How do I interpret user needs and incorporate them into a program?

I start by identifying the core user actions and goals, such as creating, updating, and deleting records. Each feature in this project addresses a real-world use case, such as managing contacts, tasks, or appointments. I design the program around these workflows to ensure it is intuitive and reliable.

To meet user expectations, I incorporate input constraints and validation logic to prevent errors. For example, I implement future date checks for appointments and set character limits for names and descriptions. These constraints are designed to simulate a real-world production environment, where data consistency is crucial. By focusing on the end user’s experience and anticipating potential mistakes, I can develop software that is both user-friendly and robust.

How do I approach designing software?

I begin by identifying the core user actions and goals, such as creating, updating, and deleting records. Each feature in this project is designed to address a real-world use case, such as managing contacts, tasks, or appointments. I structure the program around these workflows to ensure it is both intuitive and reliable.

To meet user expectations, I include input constraints and validation logic to prevent errors. For instance, I implement checks to ensure appointments are scheduled for future dates and set character limits for names and descriptions. These constraints aim to replicate a real-world production environment where data consistency is essential. By focusing on the end user's experience and anticipating potential mistakes, I can develop software that is user-friendly and robust.
